#!/usr/bin/python
#
# (C)opyright Xelerance 2007 2008, Paul Wouters <paul@xelerance.com>
#
# TODO: allow specifying location of conf files
# TODO: make work on debian/ubuntu (different way of starting services)
# TODO: configurable path for /etc/pki/dnssec-keys/
# TODO: DLV conf for unbound
# TODO: add the proper production/testing/harvest conf files 

import commands
import re
import os
import sys
import getopt
global namedconf
namedconf = "/etc/named.conf"
global unboundconf 
unboundconf = "/var/lib/unbound/unbound.conf"

def usage():
	print "dnssec-configure: (re)configure the Bind and/or Unbound nameserver for DNSSEC and DLV"
	print "usage: dnssec-configure [-u] [-b] [--dnssec= <on|off>] --dlv= <off| on [dlvzone]>"
	print "                        [--production] [--testing] [--harvest] [--root]"
	print "examples:"
	print "          dnssec-configure -u -b --dnssec=on --dlv=dlv.isc.org --production"
	print "          dnsec-configure --dnssec=on -dlv=on --production --testing --harvest"
	print "          dnssec-configure --dnssec=off -dlv=off"
        
	print "          -b or -n                 = (re)configure the Bind nameserver (default yes if found)"
	print "          -u                       = (re)configure the Unbound nameserver (default yes if found)"
	print "          --dnssec <on|of>          = enable or disable DNSSEC"
	print "          --dlv <off|on|dlvname>    = enable or disable DLV (default dlv as specified with 'on' is dlv.isc.org)" 
	print "          --basedir                = basedir for key files, default is /etc/pki/dnssec-keys/"
	print "          --production             = load production keys into configuration (default yes)"
	print "          --testing                = load testing keys into configuration (default no)"
	print "          --harvest                = load harvest keys into configuration (default no)"
	print "          --root                   = load root key into configuration [not yet implemented]"

def main(argv=None):
#	if commands.getoutput( "whoami" ) != "root":
#		sys.exit("root permission is required  to write config files"

	if argv is None:
		argv = sys.argv
	try:
		opts, args = getopt.getopt(argv[1:], "bnuvh1:2:3:4567", ["bind","named", "unbound", "version","help","dnssec=","dlv=","basedir=","production","testing","harvest","root"])
	except getopt.error, msg:
		#print >>sys.stderr, err.msg
		print >>sys.stderr, "ERROR parsing options"
		usage()
		sys.exit(2)

	# parse options
	dlvzone = "dlv.isc.org"
	basedir = "/etc/pki/dnssec-keys/"
	# Using conf files for 'grep' will cause failure when using
	# includes, so we need to go through those as well
	bind = 0
	unbound = 0
	dnssec = -1
	dlv = -1
	production = ""
	testing = ""
	harvest = ""
	root = ""
	if not opts:
		usage()
		sys.exit()
		
	for o, a in opts:
		if o in ("-v", "--version"):
			print "dnssec-configure version 0.1 "
			print "Author:\n Paul Wouters <paul@xelerance.com>"
			print "Source : http://www.xelerance.com/software/dnssec-keys/"
			sys.exit()
		if o in ("-h", "--help"):
			usage()
			sys.exit()

		if o in ("-n","--named","-b","--bind"):
			bind = 1
		if o in ("-u","--unbound"):
			unbound = 1
		if o in ("-3","--basedir"):
			if not a:
				print "error: basedir requires argument"
				usage()
				sys.exit()
			else:
				basedir = a
		if o in ("--production"):
			production = 1
		if o in ("--testing"):
			testing = 1
		if o in ("--harvest"):
			harvest = 1
		if o in ("--root"):
			root = 1

		if o in ("-1","--dnssec"):
			if not a:
				print "error: no dnssec mode specified"
				usage()
				sys.exit()
			else:
				if a == "on":
					dnssec = 1
				elif a == "off":
					dnssec = 0
				else:
					print "error: dnssec can only be 'on' or 'off'"
					usage()
					sys.exit()
		if o in ("-2","--dlv"):
			if not a:
				print "error: no dlv mode specified"
				usage()
				sys.exit()
			else:
				if a == "on":
					dlv = 1
				elif a == "off":
					dlv = 0
				else:
					dlv = 1
					dlvzone = a
	if not bind and not unbound:
		# nothing specified, default is both
		bind = 1
		unbound = 1
	# check write perms
	if bind:
		try:
			fp = open(namedconf,"a")
			fp.close()
		except:
			sys.exit("error: cannot write %s"%namedconf)
	if unbound:
		try:
			fp = open(unboundconf,"a")
			fp.close()
		except:
			sys.exit("error: cannot write %s"%unboundconf)

	if not dnssec:
		# then also disable dlv
		dlv = 0
	if dlv == -1:
		print "error: dlv setting not specified"
		usage()
		sys.exit()

	if dnssec == -1:
		print "error: dnssec setting not specified"
		usage()
		sys.exit()


	if args:
		print "error:unknown arguments specified"
		usage()
		sys.exit()

	software = []
	if bind:
		software.append("bind")
	if unbound:
		software.append("unbound")
	software = ",".join(software)

	if dnssec:
		# create conffiles string to include
		conffiles = ""
		if production: conffiles = conffiles + basedir + "/production.conf"
		if testing: conffiles = conffiles + basedir + "/testing.conf"
		if harvest: conffiles = conffiles + basedir + "/harvest.conf"
		if root: conffiles = conffiles + basedir + "/root.conf"
		if not dlv:
			dlvzone = ""
		else:
			# fix dots, eg ".arpa" and "arpa" to "arpa."
			if dlvzone != ".":
				if dlvzone[-1] != ".":
					dlvzone = dlvzone + "."
				if dlvzone[0] == ".":
					dlvzone = dlvzone[1:]

		print "Enabling DNSSEC for: %s\n"%software
		if bind:
			BindEnableDNSSEC(dlvzone)
		if unbound:
			UnboundEnableDNSSEC(dlvzone)
	else:
		print "Disabling DNSSEC for: %s\n"%software
		if bind:
			BindDisableDNSSEC()
		if unbound:
			UnboundDisableDNSSEC()

	# we modified the config files, verify and restart (not reload)
	if bind:
		checkBindConfig()
		restartDaemon("named")
	if unbound:
		checkUnboundConfig()
		restartDaemon("unbound")

def restartDaemon(daemon):
	(status, output) = commands.getstatusoutput("/sbin/service %s restart"%daemon)
        if status:
                print "ERROR:%s"%output


def checkUnboundConfig():
	global unboundconf
	checkConfig(unboundconf,"unbound-checkconf")

def checkBindConfig():
	global namedconf
	checkConfig(namedconf,"named-checkconf")

# check will abort everything if it fails
def checkConfig(conf, checkprog):
	if not os.path.isfile(conf):
		sys.exit("ERROR: %s not found for rewrite")
	# *-checkconf better be in our path
	(status, output) = commands.getstatusoutput("%s %s"%(checkprog,conf))
	if status != 0:
		sys.exit("ERROR: syntax check for %s %s failed:%s"%(checkprog, conf,output))

# DNSSEC rewrite functions
def BindEnableDNSSEC(dlvzone):
	checkBindConfig()
	BindSetDNSSEC("yes",dlvzone)

def BindDisableDNSSEC():
	checkBindConfig()
	BindSetDNSSEC("no","")

def BindSetDNSSEC(yesno,dlvzone):
	global namedconf
	fp = open(namedconf)
	cnf = fp.readlines()
	fp.close()

	# find options sections. Assumptions for now: options { start on newline
	# and first }; on a line by itself is the options closing tag
	print "finding options section..."
	startopt = 0
	endopt = 0
	for index, item in enumerate(cnf):
        	if re.match("^\s*options\s*{",item):
			print "Found options line at %s:%s"%(index,item)
			startopt = index
			break
	if not startopt:
		sys.exit( "not found options sections")

	for index,item in enumerate(cnf[startopt:]):
		if re.match("^\s*}\s*;\s*\n*$",item):
			print "Found closing match at %s:%s"%(index+startopt,item)
			endopt = index
			break
	if not endopt:
		print cnf[14:]
		sys.exit( "not found options sections")

	optionscfg = cnf[startopt:startopt+endopt+1] 

	enablefound = 0 
	validationfound = 0
	dlvfound = 0
	for index,item in enumerate(optionscfg):
		# change entry if there
		if "dnssec-enable" in item:
			enablefound = 1
			(head,tail) = item.split("dnssec-enable")
			optionscfg[index] = head + "dnssec-enable %s;\n"%yesno
		if "dnssec-validation" in item:
			validationfound = 1
			(head,tail) = item.split("dnssec-validation")
			optionscfg[index] = head + "dnssec-validation %s;\n"%yesno
		if "dnssec-lookaside" in item:
			dlvfound = 1
			if not dlvzone:
				optionscfg[index] = "// %s"%item
			else:
				(head,tail) = item.split("dnssec-lookaside")
				optionscfg[index] = head + "dnssec-lookaside . trust-anchor " + dlvzone + ";\n"
	# add entry for unfound settings
	if not enablefound:
		optionscfg = optionscfg[:-1] + ["dnssec-enable %s;\n"%yesno] + [ "];\n" ]
	if not validationfound:
		optionscfg = optionscfg[:-1] + ["dnssec-validation %s"%yesno] + [ "};\n" ]
	if dlvzone and not dlvfound:
		optionscfg = optionscfg[:-1] + ["dnssec-lookaside . trust-anchor %s"%dlvzone] + [ "};\n" ]


	fpnew = open("/tmp/named.conf","w")
	fpnew.write("".join(cnf[1:startopt]))
	fpnew.write("".join(optionscfg))
	fpnew.write("".join(cnf[(startopt+endopt+1):]))
	fpnew.close()
	print "wrote /tmp/named.conf"
	# must add trusted-keys sections now.

def UnboundEnableDNSSEC(dlvzone):
	UnboundSetDNSSEC("yes",dlvzone)

def UnboundDisableDNSSEC():
	UnboundSetDNSSEC("no","")

# easiest is to remember is start of server: section
#val-permissive-mode: yes
def UnboundSetDNSSEC(yesno,dlvzone):
	global unboundconf
	fp = open(unboundconf)
	cnf = fp.readlines()
	fp.close()
	# flip the yesno arround because we say 'yes' to disable dnssec
	if yesno == "yes":
		yesno = "no"
	else:
		yesno = "yes"

	# first try if we find the option, if not add to start of server: section
	serversect = 0
	permissive = 0
	commentpermissive = 0
	for index, item in enumerate(cnf):
        	if re.match("^\s*server:\s*",item):
			print "Found server: line at %s:%s"%(index,item)
			serversect = index
        	if re.match("^\s*val-permissive-mode\s*:",item):
			print "Found val-permissive-mode line at %s:%s"%(index,item)
			permissive = index
        	if re.match("^\s*#\s*val-permissive-mode\s*:",item):
			print "Found #val-permissive-mode line at %s:%s"%(index,item)
			commentpermissive = index
	if permissive:
		(head,tail) = cnf[permissive].split("val-permissive-mode")
		cnf[permissive] = "%sval-permissive-mode: %s\n"%(head,yesno)
	elif commentpermissive:
		(head,tail) = cnf[commentpermissive].split("#",1)
		cnf[commentpermissive] = "%sval-permissive-mode: %s\n"%(head,yesno)
	else:
		cnf = cnf[1:serversect] + [ "   val-permissive-mode: %s"%yesno ] + cnf[serversect:]

	fp = open("/tmp/unbound.conf","w")
	fp.write("".join(cnf))
	fp.close()


if __name__ == "__main__":
	sys.exit(main())


