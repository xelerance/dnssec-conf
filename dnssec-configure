#!/usr/bin/python
#
# (C)opyright Xelerance 2007 2008, Paul Wouters <paul@xelerance.com>
#
# TODO: allow specifying location of conf files
# TODO: make work on debian/ubuntu (different way of starting services)
# TODO: configurable path for /etc/pki/dnssec-keys/
# TODO: add the proper production/testing/harvest conf files 

import commands
import re
import os
import sys
import getopt
import tempfile,shutil

global namedconf
namedconf = "/etc/named.conf"
global unboundconf 
unboundconf = "/etc/unbound/unbound.conf"
global bversion
bversion = "unknown"

def usage():
	print "dnssec-configure: (re)configure the Bind and/or Unbound for DNSSEC and DLV"
	print "usage: dnssec-configure [-u] [-b] [--dnssec=<on|off>] --dlv=<off|on[dlvzone]>"
	print "                        [--production] [--testing] [--harvest] [--root]"
	print "examples:"
	print "   dnssec-configure -u -b --dnssec=on --dlv=dlv.isc.org --production"
	print "   dnsec-configure --dnssec=on -dlv=on --production --testing --harvest"
	print "   dnssec-configure --dnssec=off -dlv=off"
        print ""
	print "   -b or -n          (re)configure the Bind nameserver (default yes if found)"
	print "   -u                (re)configure the Unbound nameserver (default yes if found)"
	print "   --dnssec <on|of>  enable or disable DNSSEC"
	print "   --dlv <off|on|dlvname> enable or disable DLV (default dlv as specified with 'on' is dlv.isc.org)" 
	print "   --basedir         basedir for key files, default is /etc/pki/dnssec-keys/"
	print "   --production      load production keys into configuration (default yes)"
	print "   --testing         load testing keys into configuration (default no)"
	print "   --harvest         load harvest keys into configuration (default no)"
	print "   --root            load root key into configuration [not yet implemented]"

def main(argv=None):
#	if commands.getoutput( "whoami" ) != "root":
#		sys.exit("root permission is required  to write config files"

	if argv is None:
		argv = sys.argv
	try:
		opts, args = getopt.getopt(argv[1:], "bnuvh1:2:3:4567", ["bind","named", "unbound", "version","help","dnssec=","dlv=","basedir=","production","testing","harvest","root"])
	except getopt.error, msg:
		#print >>sys.stderr, err.msg
		print >>sys.stderr, "ERROR parsing options"
		usage()
		sys.exit(2)

	# parse options
	dlvzone = "dlv.isc.org"
	basedir = "/etc/pki/dnssec-keys/"
	# Using conf files for 'grep' will cause failure when using
	# includes, so we need to go through those as well
	bind = 0
	unbound = 0
	dnssec = -1
	dlv = -1
	production = ""
	testing = ""
	harvest = ""
	root = ""
	if not opts:
		usage()
		sys.exit()
		
	for o, a in opts:
		if o in ("-v", "--version"):
			print "dnssec-configure version 0.1 "
			print "Author:\n Paul Wouters <paul@xelerance.com>"
			print "Source : http://www.xelerance.com/software/dnssec-keys/"
			sys.exit()
		if o in ("-h", "--help"):
			usage()
			sys.exit()

		if o in ("-n","--named","-b","--bind"):
			bind = 1
		if o in ("-u","--unbound"):
			unbound = 1
		if o in ("-3","--basedir"):
			if not a:
				print "error: basedir requires argument"
				usage()
				sys.exit()
			else:
				basedir = a
		if o in ("--production"):
			production = 1
		if o in ("--testing"):
			testing = 1
		if o in ("--harvest"):
			harvest = 1
		if o in ("--root"):
			root = 1

		if o in ("-1","--dnssec"):
			if not a:
				print "error: no dnssec mode specified"
				usage()
				sys.exit()
			else:
				if a == "on":
					dnssec = 1
				elif a == "off":
					dnssec = 0
				else:
					print "error: dnssec can only be 'on' or 'off'"
					usage()
					sys.exit()
		if o in ("-2","--dlv"):
			if not a:
				print "error: no dlv mode specified"
				usage()
				sys.exit()
			else:
				if a == "on":
					dlv = 1
				elif a == "off":
					dlv = 0
				else:
					dlv = 1
					dlvzone = a
	if not bind and not unbound:
		# nothing specified, default is both
		bind = 1
		unbound = 1
	# check write perms
	if bind:
		try:
			fp = open(namedconf,"a")
			fp.close()
		except:
			sys.exit("error: cannot write %s"%namedconf)
	if unbound:
		try:
			fp = open(unboundconf,"a")
			fp.close()
		except:
			sys.exit("error: cannot write %s"%unboundconf)

	if not dnssec:
		# then also disable dlv
		dlv = 0
	if dlv == -1:
		print "error: dlv setting not specified"
		usage()
		sys.exit()

	if dnssec == -1:
		print "error: dnssec setting not specified"
		usage()
		sys.exit()


	if args:
		print "error:unknown arguments specified"
		usage()
		sys.exit()

	software = []
	if bind:
		software.append("bind")
	if unbound:
		software.append("unbound")
	software = ",".join(software)

	if dnssec:
		# create conffiles string to include
		conffiles = ""
		if production: conffiles = conffiles + basedir + "/production.conf"
		if testing: conffiles = conffiles + basedir + "/testing.conf"
		if harvest: conffiles = conffiles + basedir + "/harvest.conf"
		if root: conffiles = conffiles + basedir + "/root.conf"
		if not dlv:
			dlvzone = ""
		else:
			# fix dots, eg ".arpa" and "arpa" to "arpa."
			if dlvzone != ".":
				if dlvzone[-1] != ".":
					dlvzone = dlvzone + "."
				if dlvzone[0] == ".":
					dlvzone = dlvzone[1:]

		print "Enabling DNSSEC for: %s"%software
		if bind:
			BindEnableDNSSEC(dlvzone)
		if unbound:
			UnboundEnableDNSSEC(dlvzone)
	else:
		print "Disabling DNSSEC for: %s"%software
		if bind:
			BindDisableDNSSEC()
		if unbound:
			UnboundDisableDNSSEC()

	# we modified the config files, verify and restart (not reload)
	if bind:
		checkBindConfig()
		restartDaemon("named")
	if unbound:
		checkUnboundConfig()
		restartDaemon("unbound")

def restartDaemon(daemon):
	(status, output) = commands.getstatusoutput("/sbin/service %s restart"%daemon)
        if status:
                print "ERROR:\n%s"%output


def checkUnboundConfig():
	global unboundconf
	checkConfig(unboundconf,"unbound-checkconf")

def checkBindConfig():
	global namedconf
	checkConfig(namedconf,"named-checkconf")

# Check if bind version is 9.3.3 - 9.6.x
def checkBindVersion():
	global bversion
	(status,bversion) = commands.getstatusoutput("named -v");
	if status != 0 or bversion == "":
		sys.exit("ERROR: unknown problem with named: %s "%bversion)
	try:
		if bversion[0:5] <> "BIND ":
			sys.exit("ERROR: unknown Bind version '%s'- aborted:"%bversion)
		if (bversion[5] in [ "4","8" ]):
			sys.exit("ERROR: ANCIENT Bind version '%s' not supported. We only support 9.3.3 and higher"%bversion)
		if (bversion[5] == "9") and (bversion[7] in [ "4","5","6" ]):
			bversion = "newstyle"
			return
		elif (bversion[5] == "9") and (bversion[7] =="3"):
			if  bversion[9] in ["1","2"]:
				sys.exit("ERROR: Bind version '%s' not supported. We only support 9.3.3 and higher"%bversion)
			bversion = "oldstyle"
			return
		sys.exit("ERROR: unknown Bind version '%s'- aborted"%bversion)
	except:
		sys.exit("ERROR: unknown Bind version syntax '%s'- aborted:"%bversion)

# check will abort everything if it fails
def checkConfig(conf, checkprog):
	if not os.path.isfile(conf):
		sys.exit("ERROR: %s not found for rewrite")
	# *-checkconf better be in our path
	(status, output) = commands.getstatusoutput("%s %s"%(checkprog,conf))
	if status != 0:
		sys.exit("ERROR: syntax check for %s %s failed:%s"%(checkprog, conf,output))

# DNSSEC rewrite functions
def BindEnableDNSSEC(dlvzone):
	checkBindConfig()
	checkBindVersion()
	BindSetDNSSEC("yes",dlvzone)

def BindDisableDNSSEC():
	checkBindConfig()
	BindSetDNSSEC("no","")

def BindSetDNSSEC(yesno,dlvzone):
	global namedconf
	global bversion
	fp = open(namedconf)
	cnf = fp.readlines()
	fp.close()

	# find options sections. Assumptions for now: options { start on newline
	# and first }; on a line by itself is the options closing tag
	startopt = 0
	endopt = 0
	for index, item in enumerate(cnf):
        	if re.match("^\s*options\s*{",item):
			startopt = index
			break
	if not startopt:
		sys.exit( "not found options sections")

	for index,item in enumerate(cnf[startopt:]):
		if re.match("^\s*}\s*;\s*\n*$",item):
			endopt = index
			break
	if not endopt:
		print cnf[14:]
		sys.exit( "not found options sections")

	optionscfg = cnf[startopt:startopt+endopt+1] 

	enablefound = 0 
	validationfound = 0
	dlvfound = 0
	for index,item in enumerate(optionscfg):
		# change entry if there
		if "dnssec-enable" in item:
			enablefound = 1
			optionscfg[index] = "\tdnssec-enable %s;\n"%yesno
		if "dnssec-validation" in item:
			validationfound = 1
			if bversion == "newstyle":
				optionscfg[index] = "\tdnssec-validation %s;\n"%yesno
			else:
				optionscfg[index] = "\t// only in bind 9.3.3 and newer: dnssec-validation %s;\n"%yesno
		if "dnssec-lookaside" in item:
			dlvfound = 1
			if not dlvzone:
				vals = item.split("dnssec-lookaside")[1]
				optionscfg[index] = "\t// dnssec-lookaside%s"%vals
			else:
				optionscfg[index] = "\tdnssec-lookaside . trust-anchor " + dlvzone + ";\n"
	# add entry for unfound settings
	if not enablefound:
		optionscfg = optionscfg[:-1] + ["\tdnssec-enable %s;\n"%yesno] + [ "};\n" ]
	if not validationfound:
		if bversion == "newstyle":
			optionscfg = optionscfg[:-1] + ["\tdnssec-validation %s;\n"%yesno]  + [ "};\n" ]
		else:
			optionscfg = optionscfg[:-1] + ["\t// only in bind 9.3.3 and newer: dnssec-validation %s;\n"%yesno]  + [ "};\n" ]
	if dlvzone:
		if not dlvfound:
			optionscfg = optionscfg[:-1] + ["\tdnssec-lookaside . trust-anchor %s;\n"%dlvzone]  + [ "};\n" ]
		if not os.path.isfile("/etc/pki/dnssec-keys/dlv/%sconf"%dlvzone):
			print "warning: /etc/pki/dnssec-keys/dlv/%sconf not found. If you trust your network use:"%dlvzone
			print "         dnskey-pull -t -o /etc/pki/dnssec-keys/dlv/%sconf %s' to obtain it"%(dlvzone,dlvzone)

	(fptmp,fname) = tempfile.mkstemp(".conf")
	fpnew = os.fdopen(fptmp, 'w+b')
	fpnew.write("".join(cnf[0:startopt]))
	fpnew.write("".join(optionscfg))
	fpnew.write("".join(cnf[(startopt+endopt+1):]))
	# TODO must add trusted-keys sections here.
	fpnew.close()
	try:
		os.unlink(namedconf +".bak")
	except:
		pass
	shutil.copy2(namedconf, namedconf +".bak")
	shutil.copy2(fname, namedconf)
	# copy original owner/group to new file
	owner = os.stat(namedconf)[ST_UID]
	group = os.stat(namedconf)[ST_GID]
	os.chown(unboundconf,owner,group)
	# copy original permissions to new file
	shutil.copymode(namedconf +".bak",namedconf)
	os.unlink(fname)

def UnboundEnableDNSSEC(dlvzone):
	UnboundSetDNSSEC("yes",dlvzone)

def UnboundDisableDNSSEC():
	UnboundSetDNSSEC("no","")

# easiest is to remember is start of server: section
#val-permissive-mode: yes
def UnboundSetDNSSEC(yesno,dlvzone):
	global unboundconf
	fp = open(unboundconf)
	cnf = fp.readlines()
	fp.close()
	# flip the yesno arround because we say 'yes' to disable dnssec
	if yesno == "yes":
		yesno = "no"
	else:
		yesno = "yes"

	# first try if we find the option, if not add to start of server: section
	serversect = 0
	permissive = 0
	commentpermissive = 0
	dlvanchorfile = 0
	for index, item in enumerate(cnf):
        	if re.match("^\s*server:\s*",item):
			serversect = index
        	if re.match("^\s*val-permissive-mode\s*:",item):
			permissive = index
        	if re.match("^\s*#\s*val-permissive-mode\s*:",item):
			commentpermissive = index
        	if dlvzone and not dlvanchorfile: 
			if re.match("^\s*#*\s*dlv-anchor-file\s*:",item):
				dlvanchorfile = index
	if permissive:
		(head,tail) = cnf[permissive].split("val-permissive-mode")
		cnf[permissive] = "%sval-permissive-mode: %s\n"%(head,yesno)
	elif commentpermissive:
		(head,tail) = cnf[commentpermissive].split("#",1)
		cnf[commentpermissive] = "%sval-permissive-mode: %s\n"%(re.sub("#","",head),yesno)
	else:
		cnf = cnf[1:serversect] + [ "   val-permissive-mode: %s"%yesno ] + cnf[serversect:]
	if dlvzone:
		if dlvanchorfile:
			(head,tail) = cnf[dlvanchorfile].split("dlv-anchor-file")
			cnf[dlvanchorfile] = "%s dlv-anchor-file: /etc/pki/dnssec-keys/dlv/%skey"%(re.sub("#","",head),dlvzone)
		else:
			cnf = cnf[1:serversect] + [ "%sdlv-anchor-file: /etc/pki/dnssec-keys/dlv/%skey"%(head,dlvzone) ] + cnf[serversect:]

		if not os.path.isfile("/etc/pki/dnssec-keys/dlv/%skey"%dlvzone):
			print "warning: /etc/pki/dnssec-keys/dlv/%skey not found. If you trust your network use 'dnskey-pull' to obtain it"%dlvzone
	
	(fptmp,fname) = tempfile.mkstemp(".conf")
	fpnew = os.fdopen(fptmp, 'w+b')
	fpnew.write("".join(cnf))
	# TODO must add trusted keys include? 
	fpnew.close()
	try:
		os.unlink(unboundconf +".bak")
	except:
		pass
	shutil.copy2(unboundconf, unboundconf +".bak")
	shutil.copy2(fname, unboundconf)
	# copy original owner/group to new file
	owner = os.stat(unboundconf)[ST_UID]
	group = os.stat(unboundconf)[ST_GID]
	os.chown(unboundconf,owner,group)
	# copy original permissions to new file
	shutil.copymode(unboundconf +".bak",unboundconf)
	os.unlink(fname)

if __name__ == "__main__":
	sys.exit(main())


